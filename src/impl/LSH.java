package impl;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;

/**
 * This class implements the Locality Sensitive Hashing (LSH) algorithm
 * for efficient near-neighbor search in a large dataset of text documents.
 */
public class LSH {

	/**
	 * text documents that share the same hash value for a given sub vector
	 */
    public List<HashMap<String, List<String>>> buckets;


	/**
	 * initializes a list of hash buckets with a given number of bands
	 * @param band band size
	 */
    public LSH(int band) {
    	buckets = new ArrayList<HashMap<String, List<String>>>();
    	for(int i = 0; i < band; i++) {
    		buckets.add(new HashMap<>());
    	}
    }

	/**
	 * Takes a signature (a list of integers generated by a MinHash algorithm)
	 * and divides it into sub vectors of equal length
	 * @param band band size
	 * @param signature a list of integers generated by a MinHash algorithm
	 * @return sub vectors are returned as a 2D array
	 */
    public int[][] segBand(int band, ArrayList<Integer> signature) {
    	if(signature.size() % band == 0) {
    		int l = signature.size();
    		int row = l / band;
    		int[][] subvecs = new int[band][row];
    		// break signature into subvectors
    		for (int i = 0; i < l; i += row) {
    			for (int j = 0; j < row; j++) {
    				subvecs[i / row][j] = signature.get(i + j);
    			}
    		}
    		return subvecs;
    	}else {
    		System.out.println("Please re-define band (must an integer that can divide " + signature.size() + " )");
    		return null;
    	}
    }

	/**
	 * hashes each sub vector using a hash function and maps
	 * the resulting hash value to the corresponding bucket
	 * @param band band size
	 * @param signature a list of integers generated by a MinHash algorithm
	 * @param text a text document
	 */
    public void bucketing(int band, ArrayList<Integer> signature, String text) {
    	if(segBand(band, signature) != null) {
    		int[][] subvecs = segBand(band, signature);
    		for (int i = 0; i < band; i++) {
    			StringBuilder sb = new StringBuilder();
    			for (int j = 0; j < subvecs[i].length; j++) {
    				sb.append(subvecs[i][j]).append(",");
    			}
    			String subvec = sb.toString();
    			if (!buckets.get(i).containsKey(subvec)) {
    				buckets.get(i).put(subvec, new ArrayList<String>());
    			}
    			buckets.get(i).get(subvec).add(text);
    		}
    	}
    }

}

